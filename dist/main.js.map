{"mappings":"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","sources":["src/index.ts","src/mutation-callback.ts","src/debounce.ts"],"sourcesContent":["import mutationCallback from './mutation-callback';\n\n/**\n * Type definition for the captions receiver function.\n */\nexport interface Captions {\n    session: string;\n    activeSpeaker: string;\n    talkContent: string;\n}\nexport type captionsReceiver = (v: Captions) => void;\n/**\n * Type definition for the GetCaptionsInterface function.\n * @typedef {Function} GetCaptionsInterface\n * @param {string} cls - The class name to observe.\n * @param {captionsReceiver} receiver - The function to call when captions are received.\n */\ntype GetCaptionsInterface = (cls: string, receiver: captionsReceiver) => void;\n\nconst getCaptionLang = () => {\n    const langs: Record<string, string> = {\n        'zh-cn': '字幕',\n        'en': 'Captions',\n    }\n    const htmlElement = document.querySelector('html');\n    const lang = htmlElement?.lang?.toLowerCase() || 'en';\n    return langs[lang] || 'Captions';\n}\n\nexport const getCaptionsContainer = (): HTMLElement | null => {\n    return document.querySelector<HTMLElement>('div[aria-label=\"' + getCaptionLang() + '\"]');\n}\n\n/**\n * Waits for the target element to be available and starts observing it for mutations.\n * @param cls\n * @param {captionsReceiver} receiver - The function to call when captions are received.\n */\nconst waitForObserving = (cls: string, receiver: captionsReceiver) => {\n    const targetElement = getCaptionsContainer();\n    if (targetElement) {\n        const observer = new MutationObserver(() => {\n            console.log('mutation observed');\n            mutationCallback(receiver);\n        });\n        observer.observe(targetElement, {\n            childList: true,\n            subtree: true,\n            characterData: true\n        });\n    } else {\n        setTimeout(() => {waitForObserving(cls, receiver)}, 1000);\n    }\n}\n\n/**\n * Type definition for the GetCaptionsInterface function.\n * @param {string} cls - The class name to observe.\n * @param {captionsReceiver} receiver - The function to call when captions are received.\n */\nexport const getCaptions: GetCaptionsInterface = (cls: string, receiver: captionsReceiver) => {\n    const readyGetCaptions = () => {\n        window.requestAnimationFrame(() => {\n            if (document.readyState === 'complete') {\n                console.log('document complete');\n                waitForObserving(cls, receiver);\n            } else {\n                readyGetCaptions()\n            }\n        })\n    };\n\n    readyGetCaptions();\n}\n\nexport default getCaptions;\n","import {captionsReceiver, getCaptionsContainer} from \"./index\";\r\nimport debounce from './debounce';\r\n\r\nconst getAllCaptionDivs = () => {\r\n    const container = getCaptionsContainer();\r\n    if (!container) return [];\r\n    return Array.from(container.childNodes);\r\n};\r\n\r\nconst extractCaptionInfo = (div: ChildNode) => {\r\n    if (!div.childNodes || div.childNodes.length < 2) {\r\n        return { speaker: '', content: '' };\r\n    }\r\n    \r\n    const speakerNode = div.childNodes[0];\r\n    const contentNode = div.childNodes[1];\r\n    \r\n    if (!(speakerNode instanceof HTMLElement) || !(contentNode instanceof HTMLElement)) {\r\n        return { speaker: '', content: '' };\r\n    }\r\n\r\n    return {\r\n        speaker: speakerNode.textContent || '',\r\n        content: contentNode.textContent || ''\r\n    };\r\n};\r\n\r\ninterface SpeakerSession {\r\n    sessionId: string;\r\n    lastContent: string;\r\n    divElement: ChildNode;\r\n}\r\n\r\nlet speakerSessions: SpeakerSession[] = [];\r\n\r\nconst getOrCreateSession = (div: ChildNode, speaker: string, content: string): string => {\r\n    // Try to find existing session for this div\r\n    const existingSession = speakerSessions.find(session => session.divElement === div);\r\n    \r\n    if (existingSession) {\r\n        // Update existing session's content\r\n        existingSession.lastContent = content;\r\n        return existingSession.sessionId;\r\n    }\r\n    \r\n    // Create new session\r\n    const newSession = {\r\n        sessionId: String(new Date().getTime()),\r\n        lastContent: content,\r\n        divElement: div\r\n    };\r\n    \r\n    speakerSessions.push(newSession);\r\n    console.log('create new session', { speaker, content });\r\n    \r\n    // Clean up old sessions that are no longer in the DOM\r\n    const container = getCaptionsContainer();\r\n    if (container) {\r\n        speakerSessions = speakerSessions.filter(session => \r\n            container.contains(session.divElement)\r\n        );\r\n    }\r\n    \r\n    return newSession.sessionId;\r\n};\r\n\r\nconst mutationCallback = (receiver: captionsReceiver) => {\r\n    const captionDivs = getAllCaptionDivs();\r\n    \r\n    captionDivs.forEach(div => {\r\n        const { speaker, content } = extractCaptionInfo(div);\r\n        \r\n        if (!speaker || !content) {\r\n            return;\r\n        }\r\n\r\n        const sessionId = getOrCreateSession(div, speaker, content);\r\n\r\n        receiver({\r\n            session: sessionId,\r\n            activeSpeaker: speaker,\r\n            talkContent: content\r\n        });\r\n    });\r\n};\r\n\r\nexport default debounce(mutationCallback, 300);\r\n","type AnyFunction = (...args: any[]) => any;\r\n\r\nconst debounce = <T extends AnyFunction>(fn: T, delay: number): T => {\r\n    let timer: ReturnType<typeof setTimeout>;\r\n    return function (this: any, ...args: Parameters<T>): void {\r\n        clearTimeout(timer);\r\n        timer = setTimeout(() => {\r\n            fn.apply(this, args);\r\n        }, delay);\r\n    } as T;\r\n}\r\n\r\nexport default debounce;\r\n"],"names":[],"version":3,"file":"main.js.map"}