{"mappings":"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","sources":["src/index.ts","src/mutation-callback.ts"],"sourcesContent":["import mutationCallback from './mutation-callback';\n\n/**\n * Type definition for the captions receiver function.\n */\nexport interface Captions {\n    session: string;\n    activeSpeaker: string;\n    talkContent: string;\n}\nexport type captionsReceiver = (v: Captions) => void;\n/**\n * Type definition for the GetCaptionsInterface function.\n * @typedef {Function} GetCaptionsInterface\n * @param {string} cls - The class name to observe.\n * @param {captionsReceiver} receiver - The function to call when captions are received.\n */\ntype GetCaptionsInterface = (cls: string, receiver: captionsReceiver) => void;\n\nconst getCaptionLang = () => {\n    const langs: Record<string, string> = {\n        'zh-cn': '字幕',\n        'en': 'Captions',\n    }\n    const htmlElement = document.querySelector('html');\n    const lang = htmlElement?.lang?.toLowerCase() || 'en';\n    return langs[lang] || 'Captions';\n}\n\nexport const getCaptionsContainer = (): HTMLElement | null => {\n    return document.querySelector<HTMLElement>('div[aria-label=\"' + getCaptionLang() + '\"]');\n}\n\n/**\n * Waits for the target element to be available and starts observing it for mutations.\n * @param cls\n * @param {captionsReceiver} receiver - The function to call when captions are received.\n */\nconst waitForObserving = (cls: string, receiver: captionsReceiver) => {\n    const targetElement = getCaptionsContainer();\n    if (targetElement) {\n        const observer = new MutationObserver((mutations) => {\n            mutationCallback(mutations, receiver);\n        });\n        observer.observe(targetElement, {\n            childList: true,\n            subtree: true,\n            characterData: true\n        });\n    } else {\n        setTimeout(() => {waitForObserving(cls, receiver)}, 1000);\n    }\n}\n\n/**\n * Type definition for the GetCaptionsInterface function.\n * @param {string} cls - The class name to observe.\n * @param {captionsReceiver} receiver - The function to call when captions are received.\n */\nexport const getCaptions: GetCaptionsInterface = (cls: string, receiver: captionsReceiver) => {\n    const readyGetCaptions = () => {\n        window.requestAnimationFrame(() => {\n            if (document.readyState === 'complete') {\n                console.log('document complete');\n                waitForObserving(cls, receiver);\n            } else {\n                readyGetCaptions()\n            }\n        })\n    };\n\n    readyGetCaptions();\n}\n\nexport default getCaptions;\n","import {captionsReceiver} from \"./index\";\n\n// 从字幕 div 中提取发言人和内容\n// DOM 结构：<div aria-label=\"字幕\"> <div> <div>人名</div> <div>内容</div> </div> </div>\nconst extractCaptionInfo = (wrapperDiv: Node) => {\n    const speakerNode = wrapperDiv?.childNodes?.[0];  // 第1个div：人名\n    const contentNode = wrapperDiv?.childNodes?.[1];  // 第2个div：内容\n\n    return {\n        speaker: speakerNode?.textContent || '',\n        content: contentNode?.textContent || ''\n    };\n};\n\ninterface SpeakerSession {\n    sessionId: string;\n    lastContent: string;\n}\n\n// 用 WeakMap 存储每个字幕 div 的 session 信息\n// WeakMap 的好处：1) 查找快 O(1)  2) div 删除后自动清理\nconst speakerSessions = new WeakMap<Node, SpeakerSession>();\n\n// 处理单个字幕 div\nconst processCaptionDiv = (div: Node, receiver: captionsReceiver) => {\n    // 只处理元素节点\n    if (!(div instanceof Element) || !div) {\n        return;\n    }\n    // 提取发言人和内容\n    const { speaker, content } = extractCaptionInfo(div);\n    if (!speaker || !content) {\n        return;\n    }\n\n    // 检查这个 div 是否已经有 session\n    let session = speakerSessions.get(div);\n    \n    if (session) {\n        // 如果内容没变，不触发回调\n        if (session.lastContent === content) {\n            return;\n        }\n        // 内容变了，更新记录\n        session.lastContent = content;\n    } else {\n        // 新的 div，创建新 session\n        session = {\n            sessionId: String(Date.now()),\n            lastContent: content\n        };\n        speakerSessions.set(div, session);\n    }\n\n    // 触发回调\n    receiver({\n        session: session.sessionId,\n        activeSpeaker: speaker,\n        talkContent: content\n    });\n};\n\n// 查找包含发言人和字幕信息的 captionDiv\n// 逻辑：向上查找，直到找到父节点有 aria-label 属性的节点，那个节点就是 captionDiv\nconst findCaptionDiv = (node: Node): Element | null => {\n    let current: Node | null = node;\n    let depth = 0;\n    const MAX_DEPTH = 5; // 防止无限循环，最多向上查找10层\n    \n    // 向上遍历\n    while (current && depth < MAX_DEPTH) {\n        const parent: HTMLElement | null = current.parentElement;\n        \n        // 如果当前节点的父节点有 aria-label 属性\n        if (parent && parent.hasAttribute('aria-label')) {\n            // 说明当前节点就是我们要找的 captionDiv（字幕容器的直接子节点）\n            return current instanceof Element ? current : null;\n        }\n        \n        current = parent;\n        depth++;\n    }\n    \n    return null;\n};\n\n// MutationObserver 的回调函数\nconst mutationCallback = (mutations: MutationRecord[], receiver: captionsReceiver) => {\n    // 遍历所有变化\n    for (const mutation of mutations) {\n        // 情况1：有新增的节点（新字幕出现）\n        if (mutation.type === 'childList') {\n            // 处理新增的字幕 div\n            mutation.addedNodes.forEach(node => {\n                const captionDiv = findCaptionDiv(node);\n                if (captionDiv) {\n                    processCaptionDiv(captionDiv, receiver);\n                }\n            });\n        } \n        \n        // 情况2：文本内容变化（字幕内容更新，比如 \"Hello\" -> \"Hello world\"）\n        else if (mutation.type === 'characterData') {\n            // mutation.target 是文本节点，查找它所属的 captionDiv\n            const captionDiv = findCaptionDiv(mutation.target);\n            if (captionDiv) {\n                processCaptionDiv(captionDiv, receiver);\n            }\n        }\n    }\n};\n\nexport default mutationCallback;\n"],"names":[],"version":3,"file":"main.js.map"}