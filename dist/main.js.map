{"mappings":"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","sources":["src/index.ts","src/mutation-callback.ts","src/constant.ts","src/debounce.ts"],"sourcesContent":["import {googleMeetCaptionsClassName} from './constant';\nimport mutationCallback from './mutation-callback';\n\n/**\n * Type definition for the captions receiver function.\n */\nexport interface Captions {\n    session: string;\n    activeSpeaker: string;\n    talkContent: string;\n}\nexport type captionsReceiver = (v: Captions) => void;\n/**\n * Type definition for the GetCaptionsInterface function.\n * @typedef {Function} GetCaptionsInterface\n * @param {string} cls - The class name to observe.\n * @param {captionsReceiver} receiver - The function to call when captions are received.\n */\ntype GetCaptionsInterface = (cls: string, receiver: captionsReceiver) => void;\n\n\n\nconst getCaptionLang = () => {\n    const langs = {\n        'zh-cn': '字幕',\n        'en': 'Captions',\n    }\n    const lang = document.querySelector('html').lang?.toLowerCase();\n    return langs[lang] || 'Captions';\n}\n\n/**\n * Waits for the target element to be available and starts observing it for mutations.\n * @param cls\n * @param {captionsReceiver} receiver - The function to call when captions are received.\n */\nconst waitForObserving = (cls: string,receiver: captionsReceiver) => {\n    const targetElement = document.querySelector(cls || 'div[aria-label=\"' + getCaptionLang() + '\"]');\n    if (targetElement) {\n        const observer = new MutationObserver(() => {\n            console.log('mutation observed');\n            mutationCallback(receiver);\n        });\n        observer.observe(targetElement, {\n            childList: true,\n            subtree: true,\n            characterData: true\n        });\n    } else {\n        setTimeout(() => {waitForObserving(cls, receiver)}, 1000);\n    }\n}\n\n/**\n * Type definition for the GetCaptionsInterface function.\n * @param {string} cls - The class name to observe.\n * @param {captionsReceiver} receiver - The function to call when captions are received.\n */\nexport const getCaptions : GetCaptionsInterface = (cls: string, receiver: captionsReceiver) => {\n\n    const readyGetCaptions = () => {\n        window.requestAnimationFrame(() => {\n            if (document.readyState === 'complete') {\n                console.log('document complete');\n                waitForObserving(cls, receiver);\n            } else {\n                readyGetCaptions()\n            }\n        })\n    };\n\n    readyGetCaptions();\n\n}\n\nexport default getCaptions;\n","import {googleMeetCaptionsClassName} from './constant';\r\nimport {captionsReceiver} from \"./index\";\r\nimport debounce from './debounce';\r\n\r\nconst getCaptionsContainer = () => document.querySelector(googleMeetCaptionsClassName);\r\nconst getWhoIsSpeaking = () => getCaptionsContainer().childNodes?.[0]?.childNodes[0]?.textContent;\r\nconst getCaptionsTextContainer = () => getCaptionsContainer().childNodes?.[0]?.childNodes[1] as HTMLDivElement;\r\nconst getSpeakContent = () => getCaptionsContainer().childNodes?.[0]?.childNodes[1]?.textContent;\r\n\r\nlet whoIsSpeaking = '';\r\nconst sessionIdSpanHash= {};\r\nconst sessionInfo = {\r\n    sessionId: '',\r\n    sessionIndex: 0\r\n}\r\n\r\nconst getAllSpan = (): HTMLSpanElement[] => {\r\n    return Array.prototype.slice.call(getCaptionsTextContainer().querySelectorAll('span'));\r\n};\r\nconst addSpanTag = (sessionId) => {\r\n    getAllSpan().forEach(span => {\r\n        if (!span.hasAttribute('data-session-id')) {\r\n            span.setAttribute('data-session-id', sessionId);\r\n            span.setAttribute('data-session-index', String(sessionInfo.sessionIndex++))\r\n        }\r\n    });\r\n}\r\n\r\nconst captureCaptions = () => {\r\n    getAllSpan().forEach(span => {\r\n        const sessionId = span.getAttribute('data-session-id');\r\n        const isIgnored = span.getAttribute('data-ignored');\r\n        const sessionIndex = span.getAttribute('data-session-index');\r\n        if (isIgnored) {\r\n            return;\r\n        }\r\n        if (sessionIdSpanHash[sessionId]) {\r\n            sessionIdSpanHash[sessionId][sessionIndex] = span.textContent;\r\n        } else {\r\n            sessionIdSpanHash[sessionId] = [];\r\n            sessionIdSpanHash[sessionId][sessionIndex] = span.textContent;\r\n        }\r\n    });\r\n}\r\nconst getSessionSpeakContent = (sessionId) => {\r\n    const texts = sessionIdSpanHash[sessionId].join(\" \");\r\n    return texts;\r\n};\r\n\r\nconst markSpanShouldBeIgnored = () => {\r\n    console.log('markSpanShouldBeIgnored')\r\n     let moveIndexTo = null;\r\n    const currentSessionCaptions = getSessionSpeakContent(sessionInfo.sessionId) as string;\r\n    const allSpanArr = getAllSpan();\r\n    // @ts-ignore\r\n    allSpanArr.forEach((span, index) => {\r\n        const texts = allSpanArr.slice(0, index + 1).map(span => span.textContent).join(\" \");\r\n        if (currentSessionCaptions.indexOf(texts) !== -1) {\r\n            moveIndexTo = index;\r\n        }\r\n    })\r\n    console.log('moveIndexTo', moveIndexTo)\r\n    if (moveIndexTo !== null) {\r\n        allSpanArr.forEach((span, index) => {\r\n            if (index <= moveIndexTo) {\r\n                span.setAttribute('data-ignored', 'true');\r\n            }\r\n        })\r\n    }\r\n}\r\nconst mutationCallback = (receiver: captionsReceiver) => {\r\n    const speakContent = getSpeakContent();\r\n    const isNewOneSpeaking = getWhoIsSpeaking() !== whoIsSpeaking;\r\n    whoIsSpeaking = getWhoIsSpeaking();\r\n\r\n    if (!speakContent) {\r\n        return\r\n    }\r\n\r\n    if (isNewOneSpeaking) {\r\n        sessionInfo.sessionId = String(new Date().getTime()); // reset session id\r\n        sessionInfo.sessionIndex = 0; // reset session index\r\n        sessionIdSpanHash[sessionInfo.sessionId] = [];\r\n    }\r\n\r\n    // const currentSessionCaptions = getSessionSpeakContent(sessionInfo.sessionId);\r\n    // // 检查span是否需要忽略\r\n    // const isAllSpanDontHaveSessionId = getAllSpan().every(span => !span.hasAttribute('data-session-id'));\r\n    // console.log('isAllSpanDontHaveSessionId', isAllSpanDontHaveSessionId)\r\n    //\r\n    markSpanShouldBeIgnored();\r\n\r\n    addSpanTag(sessionInfo.sessionId)\r\n    captureCaptions();\r\n\r\n    receiver({\r\n        session: sessionInfo.sessionId,\r\n        activeSpeaker: whoIsSpeaking,\r\n        talkContent: getSessionSpeakContent(sessionInfo.sessionId)\r\n    })};\r\n\r\nexport default debounce(mutationCallback, 300);\r\n","export const googleMeetCaptionsClassName = '.uYs2ee';\r\n","const debounce = (fn, delay) => {\r\n    let timer;\r\n    return function (...args) {\r\n        clearTimeout(timer);\r\n        timer = setTimeout(() => {\r\n            fn(...args);\r\n        }, delay);\r\n    };\r\n}\r\n\r\nexport default debounce;\r\n"],"names":[],"version":3,"file":"main.js.map"}