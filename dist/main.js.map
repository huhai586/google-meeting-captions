{"mappings":"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","sources":["src/index.ts","src/constant.ts","src/mutation-callback.ts","src/debounce.ts"],"sourcesContent":["import {googleMeetCaptionsClassName} from './constant';\nimport mutationCallback from './mutation-callback';\n\n/**\n * Type definition for the captions receiver function.\n */\nexport interface Captions {\n    session: string;\n    activeSpeaker: string;\n    talkContent: string;\n}\nexport type captionsReceiver = (v: Captions) => void;\n/**\n * Type definition for the GetCaptionsInterface function.\n * @typedef {Function} GetCaptionsInterface\n * @param {string} cls - The class name to observe.\n * @param {captionsReceiver} receiver - The function to call when captions are received.\n */\ntype GetCaptionsInterface = (cls: string, receiver: captionsReceiver) => void;\n\n/**\n * Waits for the target element to be available and starts observing it for mutations.\n * @param {captionsReceiver} receiver - The function to call when captions are received.\n */\nconst waitForObserving = (receiver: captionsReceiver) => {\n    const targetElement = document.querySelector(googleMeetCaptionsClassName);\n    if (targetElement) {\n        const observer = new MutationObserver(() => {\n            console.log('mutation observed');\n            mutationCallback(receiver);\n        });\n        observer.observe(targetElement, {\n            childList: true,\n            subtree: true,\n            characterData: true\n        });\n    } else {\n        setTimeout(() => {waitForObserving(receiver)}, 1000);\n    }\n}\n\n/**\n * Type definition for the GetCaptionsInterface function.\n * @typedef {Function} GetCaptionsInterface\n * @param {string} cls - The class name to observe.\n * @param {captionsReceiver} receiver - The function to call when captions are received.\n */\nexport const getCaptions : GetCaptionsInterface = (cls = googleMeetCaptionsClassName, receiver) => {\n    const readyGetCaptions = () => {\n        window.requestAnimationFrame(() => {\n            if (document.readyState === 'complete') {\n                console.log('document complete');\n                waitForObserving(receiver);\n            } else {\n                readyGetCaptions()\n            }\n        })\n    };\n\n    readyGetCaptions();\n\n}\n\nexport default getCaptions;\n","export const googleMeetCaptionsClassName = '.uYs2ee';\n","import {googleMeetCaptionsClassName} from './constant';\nimport {captionsReceiver} from \"./index\";\nimport debounce from './debounce';\n\nconst getCaptionsContainer = () => document.querySelector(googleMeetCaptionsClassName);\nconst getWhoIsSpeaking = () => getCaptionsContainer().childNodes?.[0]?.childNodes[0]?.textContent;\nconst getCaptionsTextContainer = () => getCaptionsContainer().childNodes?.[0]?.childNodes[1] as HTMLDivElement;\nconst getSpeakContent = () => getCaptionsContainer().childNodes?.[0]?.childNodes[1]?.textContent;\n\nlet whoIsSpeaking = '';\nconst sessionIdSpanHash= {};\nconst sessionInfo = {\n    sessionId: '',\n    sessionIndex: 0\n}\n\nconst getAllSpan = (): HTMLSpanElement[] => {\n    return Array.prototype.slice.call(getCaptionsTextContainer().querySelectorAll('span'));\n};\nconst addSpanTag = (sessionId) => {\n    getAllSpan().forEach(span => {\n        if (!span.hasAttribute('data-session-id')) {\n            span.setAttribute('data-session-id', sessionId);\n            span.setAttribute('data-session-index', String(sessionInfo.sessionIndex++))\n        }\n    });\n}\n\nconst captureCaptions = () => {\n    getAllSpan().forEach(span => {\n        const sessionId = span.getAttribute('data-session-id');\n        const isIgnored = span.getAttribute('data-ignored');\n        const sessionIndex = span.getAttribute('data-session-index');\n        if (isIgnored) {\n            return;\n        }\n        if (sessionIdSpanHash[sessionId]) {\n            sessionIdSpanHash[sessionId][sessionIndex] = span.textContent;\n        } else {\n            sessionIdSpanHash[sessionId] = [];\n            sessionIdSpanHash[sessionId][sessionIndex] = span.textContent;\n        }\n    });\n}\nconst getSessionSpeakContent = (sessionId) => {\n    const texts = sessionIdSpanHash[sessionId].join(\" \");\n    return texts;\n};\n\nconst markSpanShouldBeIgnored = () => {\n    console.log('markSpanShouldBeIgnored')\n     let moveIndexTo = null;\n    const currentSessionCaptions = getSessionSpeakContent(sessionInfo.sessionId) as string;\n    const allSpanArr = getAllSpan();\n    // @ts-ignore\n    allSpanArr.forEach((span, index) => {\n        const texts = allSpanArr.slice(0, index + 1).map(span => span.textContent).join(\" \");\n        if (currentSessionCaptions.indexOf(texts) !== -1) {\n            moveIndexTo = index;\n        }\n    })\n    console.log('moveIndexTo', moveIndexTo)\n    if (moveIndexTo !== null) {\n        allSpanArr.forEach((span, index) => {\n            if (index <= moveIndexTo) {\n                span.setAttribute('data-ignored', 'true');\n            }\n        })\n    }\n}\nconst mutationCallback = (receiver: captionsReceiver) => {\n    console.warn('mutation observed');\n    const speakContent = getSpeakContent();\n    const isNewOneSpeaking = getWhoIsSpeaking() !== whoIsSpeaking;\n    whoIsSpeaking = getWhoIsSpeaking();\n\n    if (!speakContent) {\n        return\n    }\n\n    if (isNewOneSpeaking) {\n        sessionInfo.sessionId = String(new Date().getTime()); // reset session id\n        sessionInfo.sessionIndex = 0; // reset session index\n        sessionIdSpanHash[sessionInfo.sessionId] = [];\n    }\n\n    // const currentSessionCaptions = getSessionSpeakContent(sessionInfo.sessionId);\n    // // 检查span是否需要忽略\n    // const isAllSpanDontHaveSessionId = getAllSpan().every(span => !span.hasAttribute('data-session-id'));\n    // console.log('isAllSpanDontHaveSessionId', isAllSpanDontHaveSessionId)\n    //\n    markSpanShouldBeIgnored();\n\n    addSpanTag(sessionInfo.sessionId)\n    captureCaptions();\n\n    receiver({\n        session: sessionInfo.sessionId,\n        activeSpeaker: whoIsSpeaking,\n        talkContent: getSessionSpeakContent(sessionInfo.sessionId)\n    })};\n\nexport default debounce(mutationCallback, 300);\n","const debounce = (fn, delay) => {\n    let timer;\n    return function (...args) {\n        clearTimeout(timer);\n        timer = setTimeout(() => {\n            fn(...args);\n        }, delay);\n    };\n}\n\nexport default debounce;\n"],"names":[],"version":3,"file":"main.js.map"}